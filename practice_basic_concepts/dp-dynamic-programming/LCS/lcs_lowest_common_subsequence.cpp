#include <bits/stdc++.h>
#include <iostream>

using namespace std;

/*
== What is subseq.(pick or not pick concept)
Given a string, we have to find out all subsequences of it. A String is a subsequence of a given String, that is generated by deleting some character of a given string without changing its order.
Examples: 

Input : abc
Output : a, b, c, ab, bc, ac, abc

Input : aaa
Output : a, aa, aaa
*/

// Return Longest common subseq. length

// Brute force(approx. O(2^n))
int lcsBrute(string s1, string s2)
{
  // Base
  if (s1.size() == 0 || s2.size() == 0)
  {
    return 0;
  }

  if (s1[0] == s2[0])
  {
    return 1 + lcsBrute(s1.substr(1), s2.substr(1));
  }
  else
  {
    int option1 = lcsBrute(s1, s2.substr(1));
    int option2 = lcsBrute(s1.substr(1), s2);

    return max(option1, option2);
  }
}

int helper_lcsMemoization(string s1, string s2, int m, int n, int **arr)
{
  // Handle empty string edge case
  if (m == 0 || n == 0)
  {
    return 0;
  }

  // Checked for saved result
  if (arr[m][n] != -1)
  {
    return arr[m][n];
  }

  int res = 0;
  // logic
  if (s1[0] == s2[0])
  {
    res = 1 + helper_lcsMemoization(s1.substr(1), s2.substr(1), m - 1, n - 1, arr);
  }
  else
  {
    int option1 = helper_lcsMemoization(s1, s2.substr(1), m, n - 1, arr);
    int option2 = helper_lcsMemoization(s1.substr(1), s2, m - 1, n, arr);

    res = max(option1, option2);
  }

  // Save result
  arr[m][n] = res;
  return arr[m][n];
}

// Complexity O(N) -> O(m*n)
int lcsMemoization(string s1, string s2)
{
  int m = s1.size();
  int n = s2.size();

  // 2d array of size m x n for memoization
  int **arr = new int *[m + 1];
  for (int i = 0; i < m + 1; i++)
  {
    arr[i] = new int[n + 1];
    // Initialization
    for (int j = 0; j < n + 1; j++)
    {
      arr[i][j] = -1;
    }
  }

  int result = helper_lcsMemoization(s1, s2, m, n, arr);

  // Delete dynamically allotted 2d array
  for (int i = 0; i < m; i++)
  {
    delete[] arr[i];
  }
  delete[] arr;

  return result;
}

// Iterative solution - DP --> O(mxn) -> O(N),
// m and n just signify the size of s1 and s2, N is num of calls made
// Total num of calls made will be to fill the required m+1*n*1 -> N matrix for dp
int lcsDP(string s1, string s2)
{
  int m = s1.size();
  int n = s2.size();

  // Edge case
  if (m == 0 || n == 0)
  {
    return 0;
  }

  // 2d array of size m x n for memoization
  int **arr = new int *[m + 1];
  for (int i = 0; i < m + 1; i++)
  {
    arr[i] = new int[n + 1];
  }

  // Fill the initital values
  for (int i = 0; i < m + 1; i++)
  {
    arr[i][0] = 0;
  }
  for (int j = 0; j < n + 1; j++)
  {
    arr[0][j] = 0;
  }

  // Iterative loop
  for (int i = 1; i < m + 1; i++)
  {
    for (int j = 1; j < n + 1; j++)
    {
      // NOTE: Don't compare s1[i] and s[j], answer will be same but logic is wrong
      // i signify last remaining chars of s1
      // j signify last remaining chars of s2
      if (s1[m - i] == s2[n - j])
      {
        arr[i][j] = 1 + arr[i - 1][j - 1];
      }
      else
      {
        arr[i][j] = max(arr[i - 1][j], arr[i][j - 1]);
      }
    }
  }

  int result = arr[m][n];

  // Delete dynamically allotted 2d array
  for (int i = 0; i < m; i++)
  {
    delete[] arr[i];
  }
  delete[] arr;

  return result;
}

int main()
{
  // // Test1
  // int result = lcsBrute("abc", "axbycz");
  // cout << "lcsBrute result: " << result << endl;

  // // Test2
  // int result = lcsMemoization("abc", "axbycz");
  // cout << "lcsMemoization result: " << result << endl;

  // Test3
  int result = lcsDP("abc", "axbycz");
  cout << "lcsDP result: " << result << endl;
  result = lcsDP("abcdefg", "b1d3ffg");
  cout << "lcsDP result: " << result << endl;
}